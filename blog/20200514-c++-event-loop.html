<div>
  <h4>An event loop for less complexity</h4>
  <p>
    Developing web applications is not much different from developing desktop
    applications. Some code will be responsible from managing the UI and some
    code will do the "heavy lifting" by implementing some business logic. You
    don't want to let your user hanging on slow response time and having a
    sluggish UI creating a bad user experience. However slow is your business
    logic, the UI shall respond quickly.
  </p>
  <p>
    On the web, this problem is magnified by the fact that you business logic,
    most of the time, will be outsourced on a server somewhere hundreds or
    thousands kilometers away. Evey HTTP call and more generally, every
    function call that will take time shall be performed asynchronously, so that
    your UI is availalble to the user and is not being bog down by the rest of
    your application. You will be tempted to use threads to solve that problem.
    But if you ever worked with multi-threaded code, you should probably
    know how hard it is to get it right. A lot of subtle and easily reproducible
    issues will arise from multi-threaded code. And the cost of maintenance will
    dramatically increase.
  </p>
  <p>
    But it seems that the Javascript authors got that right. Javascript was
    developed as a way to make web page more dynamic and enhance HTML so that
    you are not stuck with dumb static web pages which can sometimes be limited
    if you want a more dynamic web. Javascript is an event-driven language. The
    way it works is simple and clever. Any call that will be slow (HTTP call,
    request to a local storage, computing a SHA-1 hash, etc) will be made
    asynchronous. The browser might process it using multi-threaded code (or
    not, this is entirely an implementation detail) and will give back the CPU
    to you immedialy and will generate an event when the answer is ready for the
    Javascript caller. This design is explained in detail on this <a class="visible-link"
    href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">Mozilla
    Developer Network</a> page, which does a good job at distinguishing the
    the event queue and the function stack (which is the way most languages work).
  </p>
  <p>
    In short, the event queue will be fed by events generated by the browser (user
    actions, end of processing, HTTP response) and the mono-threaded Javascript
    code consume those events one after the other in producer/consumer way. For
    example:
  </p>
    <pre><code class="javascript">
      document.addEventListener('mousemove', () => console.log('mouse moved'));
      const response = await fetch('http://example.com');
      console.log(reponse);
    </code></pre>
  <p>
    There is no risk that Javascript code is executed at the same time here, even
    if the HTTP response comes back at the same moment a user move its mouse, the
    browser will push those event in the queue and only one of those events will
    processed at the same time. This *greatly* simplifies your design. You will
    never have to worry about simultaneous execution of code and will never have
    to maintain complex system of mutexes and other semaphores to protect you from
    that rogue thread coming to get your resources.
  </p>
  <p>
    Thanks to the event loop, complexity is being reduced by a design pattern,
    systemizing the management of asynchonous event and offering a simple and
    clean api to the user to manage that complexity.
  </p>
  <h4>A toy implementation in C++</h4>
  <p>
    I often find myself developing small proof-of-concepts using Javascript
    because of its ease of use, but sometimes I would like to be able to do the
    same in C++. This lead me to investigate the possibility to implement a simple
    event-loop in modern C++ with the following requirements:
    <ol>
      <li>Must be simple to use (as simple as the Javascript event loop)</li>
      <li>No type casting, no complex registering of event handler. Plain and simple API.</li>
      <li>Event handlers have the proper event type passed to them as reference.</li>
      <li>Should be able to register handlers and inject events in event handler themselves (prevent race conditions)</li>
      <li>User can define events by just creating a class that derives from Event. There should be no need to implement a function or do anything in that class (POCO).</li>
      <li>Header only</li>
    </ol>
    I implemented it
    <a class="visible-link" href="https://gist.github.com/jdmichaud/187fc160a24dfd1f0991ca6513f737e4">here</a>
    and if I wouldn't use it in real production code, it is definitely something
    useful for quick proof-of-concepts.
  </p>
  <p>
    Events can be user-defined (actually only one event is defined by default
    which is <tt>Timeout</tt>) and you do not require any overloading for that.
    For example, if you need a event representing a key is pressed:
    <pre><code class="c++">
      class KeydownEvent: public Event {
      public:
        KeydownEvent() {}
      };
    </code></pre>
  <p>That's it. If you want to subscribe to such event:</p>
    <pre><code class="c++">
    EventLoop eventLoop;
    std::thread mainThread(&EventLoop::run, &eventLoop);

    eventLoop.add_event_listener&lt;KeyDownEvent&gt;([](KeyDownEvent& event) {
      std::cout << "*" << event.key << "*" << std::endl;
    });
    </code></pre>
  <p>
    With the advent of lambdas, writing event handler become as natural as in
    Javascript. Injecting event is pretty easy too:
    <pre><code class="c++">
      eventLoop.inject_event<KeyDownEvent>(key);
    </code></pre>
  </p>
  <p>
    The difficulties I had to face were mainly due to the type system. There are
    few possilities of reflection in C++, but there are still some useful tools
    like <tt>type_index</tt>. Variadic template arguments were also a little
    trikcy to use, the syntax being far from obvious at first. But as an
    old-timer who learned C++98 back in the day, I was surprised at how C++ got
    easy to use with the latest new language features. The improvements made to
    the compilation error messages were a life saver.
  </p>
  <p>
    <b>Post-scriptum</b>: In the process of implementing this event-loop, I
    discovered the "codereview" site of <a class="visible-link"
    href="https://codereview.stackexchange.com/">Stack Exchange</a>, and <a
    class="visible-link"
    href="https://codereview.stackexchange.com/questions/231031/event-loop-in-c">was
    amazed by the quality of the reviews</a>. Check it out!
  </p>
</div>
