<p>
  Developing web applications is not much different from developing desktop
  applications. Some code will be responsible from managing the UI and some code
  will do the "heavy lifting" by implementing some business logic. You don't want
  to let your user hanging on slow response time and having a sluggish UI creating
  a bad user experience. However slow is your business logic, the UI shall respond
  quickly.
</p>
<p>
  On the web, this problem is magnified by the fact that you business logic,
  most of the time, will be deported on a server somewhere hundreds or
  thousands kilometers away. Evey HTTP call, and more generally, every function
  call that will take time shall be performed asynchronously, so that your UI
  is availalble to the user and is not being bog down by the rest of your
  application. You will be tempted to use threads to solve that problem. But if
  you have ever worked with multi-threaded code, you should probably know how
  hard it is to get right. A lot of subtle and easily reproducible issues
  will arise from multi-threaded code. And the cost of maintenance will
  dramatically increase.
</p>
  But it seems that the Javascript authors got that right. Javascript was developed
  as a way to make web page more dynamic and enhance HTML so that you are not
  stuck with dump static web pages which can sometimes be limited if you want
  a more dynamic web. Javascript is an event-driven language. The way it works
  is simple and clever. Any call that will be slow (HTTP call, request to
  a local storage, computing a SHA-1 hash, etc) will be made asynchronous. The
  browser might process it using multi-threaded code (or not, this is entirely
  an implementation detail), will give back the CPU to you immedialy and will
  generate an event when the answer is ready for the Javascript caller. This
  design is explained in detail on this [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) page,
  which does a good job at distinguishing the function stacks(which is the
  way most languages work) and the event queue.
</p>
<p>
  In short, the event queue will be fed by events generated by the browser (user
  actions, end of processing, HTTP response) and the mono-threaded Javascript
  code consume those events one after the other in producer/consumer way.
  For example:
  <pre>
    document.addEventListener('mousemove', () => console.log('mouse moved'));
    const response = await fetch('http://example.com');
    console.log(reponse);
  </pre>
  There is no risk that Javascript code is executed at the same time here, even
  if the HTTP response comes back at the same moment a user move its mouse, the
  browser will push those event in the queue and only one of those events will
  processed at the same time. This *greatly* simplifies your design. You will
  never have to worry about simultaneous execution of code and will never have
  to maintain complex system of mutexes and other semaphores to protect you from
  that rogue thread coming to get your resources.
</p>
<p>
  Thanks to the event loop, complexity is being reduced by a design pattern,
  systemizing the management of asynchonous event and offering a simple and
  clean api to the user to manage that complexity.
</p>
<p>
  I often find myself developing small proof-of-concepts using Javascript because
  of its ease of use, but sometimes I would like to be able to do the same in C++.
  This lead me to investigate the possibility to implement a simple event-loop
  with the following requirements:
  <ol>
    <li>Must be simple to use (as simple as the Javascript event loop)</li>
    <li>No type casting, no complex registering of event handler. Plain and simple API.</li>
    <li>Event handlers have the proper event type passed to them as reference.</li>
    <li>Should be able to register handlers and inject events in event handler themselves (prevent race conditions)</li>
    <li>User can define events by just creating a class that derives from Event. There should be no need to implement a function or do anything in that class (POCO).</li>
    <li>Header only</li>
  </ol>
  I implemented is [here](https://gist.github.com/jdmichaud/187fc160a24dfd1f0991ca6513f737e4)
  and, if I wouldn;t use it in real production code, it is definitely something
  useful for quick POCs.
</p>
<p>
  Events can be user-defined (actually only one event is defined by default which
  is <tt>Timeout</tt>) and you do not require any overloading for that. 
  For example, if you need a event for when a key is pressed:
  <pre>
    class KeydownEvent: public Event {
    public:
      KeydownEvent() {}
    };
  </pre>
  That's it. If you want to subscribe to such event:
  <pre>
  EventLoop eventLoop;
  std::thread mainThread(&EventLoop::run, &eventLoop);

  eventLoop.add_event_listener<KeyDownEvent>([](KeyDownEvent& event) {
    std::cout << "*" << event.key << "*" << std::endl;
  });
  </pre>
  With the advent of lambdas, writing event handler become as natural as in
  Javascript. Injecting event is pretty easy too:
  <pre>
    eventLoop.inject_event<KeyDownEvent>(key);
  </pre>
</p>
<p>
  The difficulties I had to face were mainly due to the type system. There are
  few possilities of reflection in C++, but there are still some useful tools like
  <tt>type_index</tt>. Variadic template arguments were also a little trikcy to
  use, the syntax being far from obvious at first. But all in all I was surprised
  at how C++ got easy to use. The improvements made to the compilation error
  message were a life saver.
</p>
<p>
  Post-scriptum: In the process of implementing this event-loop, I discovered the
  "codereview" site of [Stack Exchange](https://codereview.stackexchange.com/),
  and [was amazed by the quality of the reviews](https://codereview.stackexchange.com/questions/231031/event-loop-in-c).
</p>
